Build an MVP ‚ÄúAudience Polling System‚Äù optimized for livestream + hybrid (in-room + remote) environments.

TECH STACK (required)
- Frontend: Next.js (App Router) + TypeScript + Tailwind
- Backend: Next.js API routes (or a small Node server inside Next) using WebSockets (Socket.IO recommended)
- Database: PostgreSQL (use Prisma ORM)
- Realtime counters/cache: Redis (ioredis) for fast tallies and pub/sub
- Auth: Simple email+password for Pollster/Admin (NextAuth credentials ok). Audience is anonymous by default (no login).
- Deployment: Must run locally on Ubuntu via docker

CORE ROLES
1) Pollster/Admin: creates and controls polls (‚ÄúRun of Show‚Äù cue list), opens/closes polls, reveals results, freezes, resets.
2) Audience: joins via session code/short link, votes quickly, sees question + (optional) live results when revealed.
3) Dashboard: advanced realtime results view for Pollster showing totals, momentum, and segment comparison (in-room vs remote).

KEY PRODUCT REQUIREMENTS (MVP)
A) Sessions + Join
- A ‚ÄúShow Session‚Äù has a short join code (e.g., 4-6 characters) and a public join URL: /join/[code]
- Audience enters the code or uses the URL and joins a session.
- Audience is assigned a ‚Äúsegment‚Äù automatically based on join path:
  - If they joined via /join/[code]?segment=room => segment="room"
  - Default segment="remote"
- Store a lightweight anonymous voter token in localStorage; prevent duplicate voting on the same question from the same token.

B) Pollster Control (Producer Console)
- Pollster can create a Session and build a ‚ÄúRun of Show‚Äù (cue stack) of Questions.
- Question types for MVP:
  1) Multiple choice (2‚Äì6 options)
  2) Slider (0‚Äì100)
  3) Emoji react (continuous reactions: üëç ‚ù§Ô∏è üòÇ üòÆ üò¢ üëé) ‚Äî treat as counts
- Controls per Question cue:
  - DRAFT / LIVE / CLOSED states
  - Buttons: ‚ÄúGo Live‚Äù, ‚ÄúClose‚Äù, ‚ÄúReveal Results‚Äù, ‚ÄúHide Results‚Äù, ‚ÄúFreeze‚Äù (stop updates to audience), ‚ÄúReset votes‚Äù
  - Optional duration timer (seconds); auto-close when timer ends
  - ‚ÄúBroadcast Delay (seconds)‚Äù setting at the Session level (default 0) used ONLY for dashboard visualization (see section D)

C) Realtime Voting
- When a question is LIVE, audience clients receive it instantly via WebSocket.
- Votes are submitted via WebSocket and also persisted to Postgres (append-only vote events table).
- Redis maintains fast tallies per question and per segment (room vs remote vs overall).
- Realtime updates:
  - Pollster dashboard always sees live updates.
  - Audience only sees results if ‚ÄúReveal Results‚Äù is enabled for that question.

D) Dashboard (Advanced but MVP)
Create a Pollster dashboard page that shows:
- Current LIVE question card with:
  - Total votes + votes/sec (rolling 10s)
  - Result bars for each option (or slider histogram buckets, emoji counts)
  - Segment compare: Overall vs Room vs Remote (toggle)
- Momentum chart (simple line chart) showing total votes over time for the current question (store in memory or build from periodic snapshots every 2s; MVP can keep last 5 minutes).
- ‚ÄúAligned timeline‚Äù view:
  - If Session has broadcastDelaySeconds > 0, show a second metric labeled ‚ÄúTime-aligned votes‚Äù = votes counted but displayed as if shifted by delay (MVP: just shift the timestamp buckets by delay for the chart; no need to delay the actual question delivery yet).
- Integrity panel (basic):
  - show top vote sources by segment
  - flag if votes/sec exceeds a threshold (configurable)

E) Broadcast Output
- Provide a public ‚Äúoverlay‚Äù route: /overlay/[code]
- Overlay shows the current question and results in a clean graphics-friendly layout (safe margins, big text).
- Overlay respects Reveal/Hide and Freeze.
- Provide a REST endpoint returning current overlay JSON:
  GET /api/sessions/[code]/overlay
  returns { session, question, state, resultsOverall, resultsBySegment }

DATA MODEL (Prisma) ‚Äî implement
- User (pollster)
- Session { id, code, name, broadcastDelaySeconds, createdById }
- Question { id, sessionId, order, type, prompt, optionsJson, state, isRevealed, isFrozen, durationSeconds, openedAt, closedAt }
- VoteEvent { id, sessionId, questionId, voterTokenHash, segment, payloadJson, createdAt }
Notes:
- voterTokenHash should be a hash of the localStorage token (don‚Äôt store raw token).
- payloadJson varies by question type:
  - multiple choice: { optionId }
  - slider: { value }
  - emoji: { emoji }
- Add indexes for sessionId/questionId/createdAt.



WEBSOCKET EVENTS (suggested Socket.IO)
Server emits:
- session:current_question (question payload)
- session:question_state (state updates: LIVE/CLOSED/REVEALED/FROZEN)
- session:results (latest tallies overall + by segment)
Client sends:
- audience:join { code, segment, voterToken }
- audience:vote { questionId, payload }
- pollster:control { action, questionId, params }

UI REQUIREMENTS
- Modern dark UI for admin/dashboard, clean and minimal.
- Audience UI: extremely simple, big buttons, fast.
- Overlay UI: broadcast-safe, no clutter, large typography.

